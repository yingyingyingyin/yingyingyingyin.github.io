[{"title":"","date":"2020-01-14T01:25:03.243Z","path":"2020/01/14/Node/","text":"node.jsday1 node是javascript的运行时的环境，可以解析执行javascrpt,使得js不用在浏览器中就可以运行。 node的特性：（1）事件驱动（2）非阻塞IO模型（3）轻量和高效 Npm是世界上最大的开源库生态系统。 day2 用require加载模块： var http=require(&#39;http&#39;) 在Node中，没有全局作用域，只要模块作用域。 npm install npm install art_template –save(安装生产环境–【已经部署上线】中的依赖，会在package.json文件中的dependencies) npm install art-template –save-dev(安装开大环境中的依赖，会在package.json文件中的Devdependencies)","categories":[],"tags":[]},{"title":"","date":"2019-11-19T11:21:09.714Z","path":"2019/11/19/muneTree/","text":"递归(+element)嵌套实现侧边栏 Home.vue：1234567891011121314151617181920212223242526&lt;el-aside width=&quot;200px&quot; height=&quot;100%&quot;&gt; &lt;Menu :Datamenu=&quot;Datamenu&quot;&gt;&lt;/Menu&gt;&lt;/el-aside&gt;&lt;script&gt;import Menu from &quot;@/components/page/Menu.vue&quot;;export default &#123; name: &quot;home&quot;, components: &#123; Menu &#125;, data() &#123; return &#123; Datamenu: [&#123; name: &quot;About&quot;, path: &quot;/about&quot;, id: 1, children: [&#123; name: &quot;About US&quot;, path: &quot;/about/us&quot;, id: 3 &#125;, &#123; &#125;] &#125;] Menu.vue：1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;el-menu unique-opened=&quot;true&quot; background-color=&quot;#373d41&quot; text-color=&quot;#fff&quot; active-text-color=&quot;#FF4500&quot; &gt; &lt;template v-for=&quot;item in Datamenu&quot;&gt; &lt;!--如果有孩子--&gt; &lt;el-submenu :key=&quot;item.id&quot; :index=&quot;item.id&quot; v-if=&quot;item.children&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span slot=&quot;title&quot; style=&quot;padding-left:10px;&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;!--递归--&gt; &lt;Menu :Datamenu=&quot;item.children&quot;&gt;&lt;/Menu&gt; &lt;/el-submenu&gt; &lt;!--如果没有孩子--&gt; &lt;el-menu-item v-else :key=&quot;item.id&quot; :index=&quot;item.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-menu&gt; &lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;Menu&quot;, props: [&quot;Datamenu&quot;], data() &#123; return &#123;&#125;; &#125;, methods: &#123;&#125;&#125;;&lt;/script&gt;","categories":[],"tags":[]},{"title":"","date":"2019-11-14T11:11:59.335Z","path":"2019/11/14/vue-router/","text":"Vue-router 路由(一) SPA(single page application) 后端渲染（存在性能问题，像提交表单就要重新渲染） Ajax前端渲染（不支持浏览器的前进后退的操作） SPA单页面应用程序：整个网站只有一个页面，内容的变化通过Ajax局部更新实现同时支持浏览器的地址的前进和后退操作。 SPA实现原理之一：基于URL地址的hash(hash值得变化会导致浏览器访问记录的改变，但不会出发新的URL请求) 实现SPA核心技术：前端路由。 （二）Vue-router1、基本使用步骤 引入相关库文件 添加路由链接(分别对应a标签 href #) 1&lt;router-link to=&apos;user&apos;&gt;User&lt;/router-link&gt; 添加路由填充位: 1&lt;router-view&gt;&lt;/router-view&gt; 通过路由规则匹配到的组件，将会被渲染到router-view所在的位置 定义路由组件 配置路由规则并创建路由实例 123456const router=new VueRouter(&#123; routes:[&#123; path:&apos;/user&apos; component:User &#125;]&#125;) 把路由挂载到Vue根实例中 123456const vm=new Vue(&#123; el:&apos;#app&apos;, data:&#123;&#125;, //挂载路由实例对象 router&#125;) (三)重定向1234567const router=new VueRouter(&#123; //所有的路由规则 routers:[ &#123;path：&apos;/&apos;,redirect:&apos;/user&apos;&#125;, &#123;path:&apos;/user&apos;,component:User&#125; ]&#125;) (四)动态匹配路由1234解决路径前面一致要很多个路由&lt;router-link to=&apos;/user1&apos;&gt; 我是User1 &lt;router-link&gt;&lt;router-link to=&apos;/user2&apos;&gt;我是User2 &lt;router-link&gt;&lt;router-link to=&apos;/user3&apos;&gt; 我是User3&lt;router-link&gt; //解决办法： 12345678910var router=new VueRouter(&#123; routes:[&#123; path:&apos;/user/:id&apos;, component:User &#125;]&#125;)const User=&#123; tempalte:`&lt;div&gt;&#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;`&#125; (五)路由嵌套123456789101112131415161718192021222324252627282930父组件：&lt;router-link to=&apos;/User&apos;&gt;我是User1&lt;/router-link&gt;&lt;router-link to=&apos;/Regsiter&apos;&gt;我是Regsiter&lt;/router-link&gt;&lt;router-view&gt;&lt;router-view&gt;配置路由:var router=new VueRouter(&#123; routes:[&#123; path:&apos;/user&apos; component:&apos;User&apos; &#125;, &#123; path:&apos;/regsiter&apos; component:&apos;Regsiter&apos;, children:[&#123; path:&apos;/regsiter/tab1&apos;, component:Tab1 &#125;, &#123; path:&apos;/regsiter/tab2&apos;, component:Tab2 &#125;] &#125;]&#125;)const Regsiter=&#123; &lt;h1&gt;Regsiter&lt;h1&gt; &lt;router-link to=&apos;/regsiter/tab1&apos;&gt;tab1&lt;/router-link&gt; &lt;router-link to=&apos;/regsiter/tab2&apos;&gt;tab2&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&#125; 传参 父向子传参 子向父传参 非父子关系组件传参 路由实例向组件中传参 1234567891011121314151617181920212223(1)props:trueconst router=new vueRouter(&#123; routes:[ path:&apos;/user/id&apos;, component:User, props:true]&#125;),var User=&#123; props:[&apos;id&apos;], template:`&lt;div&gt;ueser:&#123;&#123;id&#125;&#125;&lt;/div&gt;&lt;/div&gt;`&#125;(2)props:对象const router=new vueRouter(&#123; routes:[path:&apos;/user/id&apos;, component:User, props:&#123;name:&apos;wyy&apos;,age:17&#125;]&#125;),var User=&#123; props:[&apos;name&apos;,&apos;age&apos;], template:`&lt;div&gt;ueser:&#123;&#123;name&#125;&#125;--&#123;&#123;age&#125;&#125;]&#125;&lt;/div&gt;&lt;/div&gt;`(3)函数 导航 声明式导航： 1&lt;a&gt;&lt;/a&gt; &lt;router-link&gt;&lt;/router-link&gt; 编程式导航： 123常用的编程式导航API如下：(1)this.$router.push(&apos;hash地址&apos;)(2)this.$router.push.go(n)","categories":[],"tags":[]},{"title":"","date":"2019-09-21T02:32:02.548Z","path":"2019/09/21/promise、async、await处理异步/","text":"处理异步的几种方法：详情见https://www.cnblogs.com/zuobaiquan01/p/8477322.html 四种方法是对比 方法一：使用回调函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /使用定时函数模拟异步请求：function doSomething(callback)&#123; setTimeout(function()&#123; console.log(&apos;执行结束&apos;); let result = 4; callback(result); &#125;,100);&#125; function callback(result)&#123; console.log(&apos;接收到结果为：&apos;+result);&#125; doSomething(callback);doSomething((result)=&gt;&#123;console.log(&apos;接收到结果为：&apos;+result)&#125;);``` // 方法二：promise对象function doSomething()&#123; return new Promise(function(resolve)&#123; setTimeout(function()&#123; console.log(&apos;执行结束&apos;); let result = 6; resolve(result); &#125;,100); &#125;); &#125; doSomething().then(result=&gt;&#123; console.log(&apos;接收到结果为：&apos;+result);&#125;);// 方法三：generator函数 function doSomething()&#123; setTimeout(function()&#123; let result = 6; it.next(result); &#125;,100);&#125; function *gener()&#123; var result = yield doSomething(); console.log(result);&#125; let it = gener();it.next(); // 方法四：async（ES7）function doSomething()&#123; return new Promise(resolve=&gt;&#123; setTimeout(function()&#123; let result = 6; resolve(result); &#125;,100); &#125;); &#125; async function action()&#123; let result = await doSomething(); console.log(result);&#125;action();","categories":[],"tags":[]},{"title":"","date":"2019-09-11T11:19:25.825Z","path":"2019/09/11/settimeout实现settimeintervel/","text":"用settimeout实现settimeinterval123456789timerFun();function timerFun()&#123; console.log(&apos;要执行的操作&apos;); let timer=setTimeout(function()&#123; timerFun(); clearTimeout(timer) &#125;,1000);&#125;","categories":[],"tags":[]},{"title":"","date":"2019-09-11T09:02:47.353Z","path":"2019/09/11/cal、apply、bindl实现/","text":"call、bind、apply的手写实现apply和call的区别就是传的参数形式不一样。call是一个一个的传，apply可以将参数以数组的形式传进去。而bind是传入第二个和后面的参数，且绑定this，返回一个转化后的函数。 考虑两点 （1） 第一个参数为undefined或null的时候，那么会转变为window（2） 改变了this执行，让新的对象可以执行该函数。 call 实现 1234567891011Function.prototype.myCall = function(context) &#123; // 判断是否是undefined和null if (typeof context === &apos;undefined&apos; || context === null) &#123; context = window &#125; context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result&#125; apply的实现 123456789101112131415Function.prototype.myApply = function(context) &#123; if (typeof context === &apos;undefined&apos; || context === null) &#123; context = window &#125; context.fn = this let args = arguments[1] let result if (args) &#123; result = context.fn(...args) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; bind实现： 这里需要注意下，因为bind转换后的函数可以作为构造函数使用，此时this应该指向构造出的实例，而bind函数绑定的第一个参数。 1234567891011121314Function.prototype.myBind = function(context) &#123; if (typeof this !== &apos;function&apos;) &#123; throw new TypeError(&apos;Error&apos;) &#125; let _this = this let args = [...arguments].slice(1) return function F() &#123; // 判断是否被当做构造函数使用 if (this instanceof F) &#123; return _this.apply(this, args.concat([...arguments])) &#125; return _this.apply(context, args.concat([...arguments])) &#125;&#125; arguments请见：https://www.cnblogs.com/lcr-smg/p/10065877.html","categories":[],"tags":[]},{"title":"","date":"2019-09-01T11:52:13.742Z","path":"2019/09/01/this、bind、apply、call/","text":"this/call/apply/bind 一、前言this指向，apply，call，bind的区别是一个经典的面试问题，同时在项目中会经常使用到的原生的js方法。同时也是ES5中的众多坑的一个。ES6中可能会极大的避免了this产生的错误，有时候需要维护老的项目还是有必要了解一下this的指向和apply，call，bind三者的区别。 二、this的指向在ES5中，其实this的指向，始终坚持一个原理：this永远指向最后一个调用它的那个对象。 首先我们看一个栗子1： 12345678var name = &quot;windowsName&quot;;function a() &#123; var name = &quot;Cherry&quot;; console.log(this.name); // windowsName console.log(&quot;inner:&quot; + this); // inner: Window&#125;a();console.log(&quot;outer:&quot; + this) // outer: Window 输出windowsName，是因为“this永远指向最后调用它的那个对象”，我们看到调用a的地方a()，前面没有调用的对象那么就是全局对象window，就是全局对象调用a()，相当于window.a()。 如果使用严格模式，全局对象就是undefined，会报错name of undefined 栗子2： 12345678var name = &quot;windowsName&quot;;var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125;&#125;a.fn(); 在这个栗子中，函数fn是对象a调用的，所以console是a中的name 栗子3: 12345678var name = &quot;windowsName&quot;; var a = &#123; name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // Cherry &#125; &#125; window.a.fn(); 这个栗子中，记住“this永远指向最后一个调用它的那个对象”，调用fn的对象有window，a，但是最后调用fn是a对象，所以this指向对象a中的name。 栗子4： 12345678var name = &quot;windowsName&quot;;var a = &#123; // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // undefined &#125;&#125;window.a.fn(); 为啥undefined，调用fn的对象有：window，a，最后一个调用fn是a，但是a中没有对那么进行定义，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined，所以this.name为undefined。 栗子5（比较坑）： 12345678910var name = &quot;windowsName&quot;;var a = &#123; name : null, // name: &quot;Cherry&quot;, fn : function () &#123; console.log(this.name); // windowsName &#125;&#125;var f = a.fn;f(); 这个栗子比较坑，为啥 不是null，因为虽然将a对象的fn方法赋值给变量f，但是没有调用，“this永远执行最后一个调用ta的那个对象”，由于刚刚的f没有调用，所以fn()最后仍然是被window调用的，所以this指向的也就是window。 注意：this的指向并不是在创建的时候可以确定，在ES5中，永远都是this永远指向最后调用它的那个对象。 1234567891011栗子6:var name = &quot;windowsName&quot;;function fn() &#123; var name = &apos;Cherry&apos;; innerFunction(); function innerFunction() &#123; console.log(this.name); // windowsName &#125;&#125;fn() 三、怎样改变this的指向改变this的指向，我总结以下的方法： （1）使用ES6中箭头函数 （2）函数内部使用_this = this （3）使用apply，call，bind方法 （4）new实例化一个对象 举个栗子7： 12345678910111213var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // this.func1 is not a function 在这个栗子中，不使用箭头函数情况下，会报错的，因为最后调用setTimeout的对象时window，但是在window并没有func1函数。 我们改变this的指向这一节将吧这个栗子作为demo进行改造。 1、ES6中的箭头函数众所周知，ES6的箭头函数是可以避免ES5中this的坑，箭头函数的this始终指向函数定义时候的this，而并不是执行时候。箭头函数需要记住这句话：“箭头函数没有this绑定，必须通过查找作用域来决定其值，如果箭头函数被非箭头函数包含，则this的绑定的是最近一层非箭头函数的this，否则，this为undefined” 栗子8： 12345678910111213var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( () =&gt; &#123; this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 2、在函数内部使用_this = this在不使用ES6中，那么这种方式应该是最简单的不会出错的方式，我们先将调用这个函数的对象保存在变量_this中，然后在函数中都使用这个_this，这样_this就不会改变了。 栗子9： 123456789101112131415var name = &quot;windowsName&quot;;var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; var _this = this; setTimeout( function() &#123; _this.func1() &#125;,100); &#125;&#125;;a.func2() // Cherry 在func2中，首先设置var _this = this，这里this是调用func2的对象a，为了防止在func2中的setTimeout被window调用而导致的在setTimeout中的this为window。我们将this赋值给一个变量_this，这样在func2中我们使用_this就是指向对象a了。 3、使用apply栗子10： 123456789101112var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.apply(a),100); &#125;&#125;;a.func2() // Cherry 在栗子中，apply()方法调用一个函数，其具有一个指定的this值，以及作为一个数组（或者类似数组的对象）提供的参数，fun.apply(thisArg, [argsArray]) thisArg：在fun函数运行时指定的this值。指定this的值并不一定是函数执行时真正的this值，如果是原始值的this会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给fun函数。参数为null或者undefined，则表示不需要传入任何参数。 4、使用call栗子11： 123456789101112var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.call(a),100); &#125;&#125;;a.func2() // Cherry 在栗子中，call()方法调用一个函数，其具有一个指定的this值，以及若干个参数列表，fun.call(thisArg, arg1, arg2, …) thisArg：在fun函数运行时指定的this值。指定this的值并不一定是函数执行时真正的this值，如果是原始值的this会指向该原始值的自动包装对象。 arg1, arg2, …：若干个参数列表 5、使用bind栗子12： 123456789101112var a = &#123; name : &quot;Cherry&quot;, func1: function () &#123; console.log(this.name) &#125;, func2: function () &#123; setTimeout( function () &#123; this.func1() &#125;.bind(a)(),100); &#125;&#125;;a.func2() // Cherry 在栗子中，bind()方法创建一个新的函数，当被调用时，将其this的关键字设置为提供的值，在调用新函数时，在任何提供一个给定的参数序列。 bind创建了一个新函数，必须手动去调用。 四、apply，call，bind区别 1、apply和call的区别 apply和call基本类似，他们的区别只是传入的参数不同。apply传入的参数是包含多个参数的数组，call传入的参数是若干个参数列表。 栗子13： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b); console.log( this.name ); &#125;&#125;var b = a.fn;b.apply(a,[1,2]) // 3 Cherry 栗子14： 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b); console.log( this.name ); &#125;&#125;var b = a.fn;b.call(a,1,2) // 3 Cherry 2、bind和apply、call区别 bind方法会创建一个新的函数，当被调用的时候，将其this关键字设置为提供的值，我们必须手动去调用。 123456789var a =&#123; name : &quot;Cherry&quot;, fn : function (a,b) &#123; console.log( a + b); console.log( this.name ); &#125;&#125;var b = a.fn;b.bind(a,1,2)() //3 //Cherry","categories":[],"tags":[]},{"title":"","date":"2019-09-01T11:24:05.019Z","path":"2019/09/01/事件冒泡、捕获/","text":"事件冒泡、捕获什么是冒泡与捕获 以click点击事件为例。假如我们有一个多层结构标签。如下图，是4个div嵌套。每个div都有点击的监听事件，分别输出1234。当我们点击最里面的div时，点击事件开始传递，传递前半部分，事件从最外面的父div依次传递到最里面的后代div，1-2-3-4这部分我们叫捕获过程。之后事件又从最里层的后代div逐层传出，4-3-2-1这部分我们叫冒泡过程。 如果我把捕获监听器和冒泡监听器都加上，如下图这样。事件传递这时我们有8个监听器了，在捕获过程和冒泡过程都有监听。输出如下图。先捕获后冒泡 如果我去除几个监听器如下图。为了容易理解我调整了格式举一反三 仍然是按照箭头顺序，明显应该输出1423。 添加两种监听的方法 在不使用任何框架的情况下，我们在js中通过addEventListener方法给Dom添加事件监听。这个方法有三个参数可以传递addEventListener(event,fn,useCapture)。event是事件类型click，focus，blur等；fn是事件触发时将执行的函数方法（function）；第三个参数可以不传，默认是false，这个参数控制是否捕获触发。所以我们只穿两个参数时，这个事件是冒泡传递触发的，当第三个参数存在且为true时，事件是捕获传递触发的。 使用框架时可使用对应的框架提供的方法。如上面我使用了Vue框架，通过事件装饰来区分捕获与冒泡。阻止传递 在不使用任何框架的情况下，我们在js中通过 stopPropagation 方法阻止事件继续传递。 使用框架时可使用对应的框架提供的方法。接下来我将了Vue框架的stop修饰符来阻止事件传递。我们可以在传递过程中阻止事件继续传递，防止触发不需要的事件。 如图我在第三层捕获后阻止事件继续传递，那么后面的log方法不会继续执行。最终只输出1-2-3。输出结果 应用场景举例 我们在使用中多数情况下只使用冒泡监听。例如一条购物车信息，在这条信息中，右下角有一个删除按钮。点击这条消息可查看详情，点击删除按钮可将此商品移除。我们会分别给信息的div和删除button添加一个冒泡的click事件监听。如果不做阻止传递，点击删除button后，会显示商品详情。显然这不是我们想看到的。这时我们给button一个阻止事件传递的功能，点击删除按钮后，事件就会结束，就不再显示商品详情。","categories":[],"tags":[]},{"title":"","date":"2019-08-21T11:45:17.600Z","path":"2019/08/21/let var let区别/","text":"1. 块作用域{ }JS中作用域有：全局作用域、函数作用域。没有块作用域的概念。ECMAScript 6(简称ES6)中新增了块级作用域。块作用域由 { } 包括，if语句和for语句里面的{ }也属于块作用域。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script type=&quot;text/javascript&quot;&gt; &#123; var a = 1; console.log(a); // 1 &#125; console.log(a); // 1 // 可见，通过var定义的变量可以跨块作用域访问到。 (function A() &#123; var b = 2; console.log(b); // 2 &#125;)(); // console.log(b); // 报错， // 可见，通过var定义的变量不能跨函数作用域访问到 if(true) &#123; var c = 3; &#125; console.log(c); // 3 for(var i = 0; i &lt; 4; i++) &#123; var d = 5; &#125;; console.log(i); // 4 (循环结束i已经是4，所以此处i为4) console.log(d); // 5 // if语句和for语句中用var定义的变量可以在外面访问到， // 可见，if语句和for语句属于块作用域，不属于函数作用域。 &#123; var a = 1; let b = 2; const c = 3; &#123; console.log(a); // 1 子作用域可以访问到父作用域的变量 console.log(b); // 2 子作用域可以访问到父作用域的变量 console.log(c); // 3 子作用域可以访问到父作用域的变量 var aa = 11; let bb = 22; const cc = 33; &#125; console.log(aa); // 11 // 可以跨块访问到子 块作用域 的变量 // console.log(bb); // 报错 bb is not defined // console.log(cc); // 报错 cc is not defined &#125;&lt;/script&gt; 2. var、let、const的区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 同一个变量只能使用一种方式声明，不然会报错 var声明变量存在变量提升，let和const不存在变量提升 同一作用域下let和const不能声明同名变量，而var可以 123456789101112131415161718192021222324252627282930313233343536373839&lt;script type=&quot;text/javascript&quot;&gt; // 块作用域 &#123; var a = 1; let b = 2; const c = 3; // c = 4; // 报错 // let a = &apos;a&apos;; // 报错 注：是上面 var a = 1; 那行报错 // var b = &apos;b&apos;; // 报错：本行报错 // const a = &apos;a1&apos;; // 报错 注：是上面 var a = 1; 那行报错 // let c = &apos;c&apos;; // 报错：本行报错 var aa; let bb; // const cc; // 报错 console.log(a); // 1 console.log(b); // 2 console.log(c); // 3 console.log(aa); // undefined console.log(bb); // undefined &#125; console.log(a); // 1 // console.log(b); // 报错 // console.log(c); // 报错 // 函数作用域 (function A() &#123; var d = 5; let e = 6; const f = 7; console.log(d); // 5 console.log(e); // 6 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) console.log(f); // 7 (在同一个&#123; &#125;中,也属于同一个块，可以正常访问到) &#125;)(); // console.log(d); // 报错 // console.log(e); // 报错 // console.log(f); // 报错&lt;/script&gt; 暂存性死区 var a = 100; if(1){ a = 10; //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a， // 而这时，还未到声明时候，所以控制台Error:a is not defined let a = 1; }版权声明：本文为CSDN博主「hot_cool」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/hot_cool/article/details/78302673","categories":[],"tags":[]},{"title":"","date":"2019-08-21T11:41:55.128Z","path":"2019/08/21/变量提升/","text":"变量提升js代码解析原则首先js引擎在读取js代码时会进行两个步骤，第一个步骤是解释，第二个步骤是执行。所谓解释就是会先通篇扫描所有的Js代码，然后把所有声明提升到顶端，第二步是执行，执行就是操作一类的。例子1： 12345&lt;script type=&quot;text/javascript&quot;&gt; console.log(a);//输出结果 undefined var a=10;&lt;/script&gt; 以上代码输出 undefined原因： 变量提升（把变量声明提升到当前执行环境的最顶端）上段代码相当于： 123var a; console.log(a);//由于未赋值 所以输出undefined a=10; 例2： 1234foo();function foo()&#123; console.log(&quot;aaa&quot;);&#125; 结果输出： aaa原理：函数声明提升 （函数声明提升直接把整个函数提到执行环境的最顶端）相当于： function foo(){ console.log(“aaa”); } foo();变量提升只提升函数名 而函数提升会提升整个函数题 注意：函数提升在变量提升上面。例3： 1234foo(); var foo = function()&#123; console.log(&quot;aaa&quot;); &#125; 运行结果是： foo is not a function原因： 还是进行了变量提升相当于： 123456var foo;console.log(foo); //undefinedfoo(); //foo is not a function foo = function()&#123; console.log(&quot;aaa&quot;); &#125; 上面代码输出undefined 是因为变量提升后并没有赋值因此输出undefined输出foo is not a function 原因是：js解析遇到 foo()时会默认当做函数来解析例4： 1234567console.log(foo); var foo=10; console.log(foo); function foo()&#123; console.log(10); &#125; console.log(foo); 输出结果：原理：相当于： 12345678function foo()&#123; console.log(10); &#125;var foo;console.log(foo);foo=10;console.log(foo);console.log(foo); 注意： 函数提升在变量提升上面，第一个console.log(foo);为什么会输出函数题呢，原因在于 var foo; 并未有赋值只是声明，因此他会调用上面的值例如: 123var b=10;b=10;console.log(b); //10 输出上一个值不会输出undefined 但是更改后： 123var b=10;b=20;console.log(b); //20 输出20不是上一个值 作者：朽木自雕也链接：https://www.jianshu.com/p/d4b88723cd12来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。","categories":[],"tags":[]},{"title":"","date":"2019-08-15T09:45:21.254Z","path":"2019/08/15/html5kuayu/","text":"跨域在跨域安全性方面，有多个地方会有限制，主要是XMLHttpRequest对象的跨域限制和iFrame的跨域限制，下面我们分别来看一下。 Ajax跨域（CORS）CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 以PHP服务端为例如果一个请求允许http://www.example.com的域请求的话，可以在PHP中这么写： 1header(&quot;Access-Control-Allow-Origin:http://www.example.com&quot;); 如果有多个允许跨域访问的地址，可以添加多条或使用“,”号进行分隔，如果希望所有来源的地址都可以访问当前的页面，可以如下： 1header(&quot;Access-Control-Allow-Origin:*&quot;); 同时，也可以控制请求的方法，如下是允许GET和POST两种请求方法： 1header(&quot;Access-Control-Allow-Method:POST,GET&quot;); IE中，要跨域需要使用到XDomainRequest的对象，我们这里就不展开来说了，而在其它浏览器中，使用XMLHttpRequest对象即可，并没有不一样的地方。 一个需要注意的地方最近在公司开发的过程中，遇见的情况是PHP已经添加了header(“Access-Control-Allow-Origin:*”);代码，但是客户端请求时，仍然报错，最终查出的bug是，包含的其它PHP中，也添加了相同的代码，导致服务端返回时，在Chrome的Network页面中，发现有两条一样的头部数据，去掉一条即可。 CORS跨域之前的跨域方法在CORS标准出现之前，XHR对象是不能跨域请求的，不过开发人员凭借自己的聪明才智，绕过了XHR对象，创造了另外几种可以跨域请求的方式，我们下面开简单的看看。 图像Ping前端里面图片元素没有跨域的限制，所以我们可以通过模拟请求一个图片的方法，向服务端发送数据，服务端对应的页面可以返回一个简单的图片数据或者什么数据都不返回（客户端得到204状态）。 1 var img = new Image();2 img.onload = img.onerror = function () {3 console.log(“Done”);4 }5 img.src = “http://www.example.com/test.php?name=LiLei&amp;age=28&quot;; 缺点是可以得到请求成功和失败的回调但是得不到服务端返回的数据，除非将数据放入图片返回。 统计在线广告浏览量等不需要返回数据的情况下通常使用该方式。 JSONP即JSON with padding的简写，简单来说：就是通过添加一个script标签，通过创建该标签的src地址来传递参数，而服务端返回JS代码的内容，JS代码回调一个页面中已经存在的JS方法，同时将需要给到客户端的信息作为参数传递即可。这样就可以绕过XHR对象实现跨域请求并得到服务端返回的数据。 12345671 function handleResponse (response) &#123;2 console.log(&quot;name: &quot; + response.name + &quot;, age: &quot; + response.age);3 &#125;4 5 var script = document.createElement(&quot;script&quot;);6 script.src = &quot;http://www.example.com/test.php?name=LiLei&amp;age=28&quot;;7 document.body.insertBefore(script, document.body.firstChild); 当前代码中的handleResponse方法即服务端会回调的方法。 handleResponse({“name”:”Han Meimei”, “age”:27}); 服务端返回上面的文本后，由于是添加的script脚本，所以会调用到handleResponse方法并得到服务端的数据。JSONP缺点 访问的其他域如果不安全，可能会返回一些有害的JS代码到当前页面进行执行； 难以确定请求失败的响应，需要用户自己实现一个超时计时器。iFrame跨域JavaScript出于安全方面的考虑，不允许iFrame跨域访问和调用其他页面的对象。 试想一下，如果我们做了一个钓鱼网站，使用一个iFrame引入了XX银行的首页，把自己伪装成该银行首页，此时如果我们可以跨域调用和修改XX银行的所有数据，也可以通过修改和注入JS代码，后果就是：如果有人登录了我们的假网站，我们就可以通过给这个iFrame添加我们自己的JS代码来轻松获得这个人的帐号和密码信息。 所以，iFrame不允许跨域访问是基于安全的考虑，也是必要的一个安全限制。 我们看下，具体的跨域限制： 12345678http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 但是不可否认的是，在某些情况下，我们还是希望不同域的页面之间可以相互通信（注意这里不一定要相互可以调用修改）。下面我们来看看如何实现跨域的消息通信。 document.domain通过修改多个框架domain属性为同样的值，可以突破跨域的限制，使多个页面之间可以互相访问到。 但是domain属性的修改有下面两个限制。只能修改子域为主域，不能修改为其它域 域example.com嵌入了域p2p.example.com的页面，通过修改p2p.example.com的domain即可实现双方互相访问和修改，如同没有跨域一样，但是要注意不能改为其它域： 121 document.domain = &quot;example.com&quot;; // 成功2 document.domain = &quot;baidu.com&quot;; // 报错 不能将主域修改为子域 如下，位于p2p.example.com的页面： 121 document.domain = &quot;example.com&quot;; // 成功2 document.domain = &quot;p2p.example.com&quot;; // 报错 因为已经设置为主域了，再次设置会子域会报错。使用postMessage 跨文档消息传递（cross-document messaging），简称XDM，在H5中该功能可以用来向iFrame嵌套的页面和嵌套自己的页面相互发送消息，也可以向当前页面弹出的窗口相互传递消息。 通过XDM我们可以安全的实现页面之间的跨域消息传递。 XDM得核心方法是postMessage，postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 postMessage(data,origin)方法接受两个参数： data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化，在低版本IE中引用json2.js可以实现类似效果。 origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为&quot;*&quot;，这样可以传递给任意窗口。而在发送了消息之后，符合条件（iFrame嵌套页面或弹出窗口，且符合postMessage的origin参数的域）的其他页面的window对象会收到该消息，作为“message”事件抛出该消息，对应的event对象有如下主要属性： data：顾名思义，是传递来的message； source：发送消息的窗口对象； origin：发送消息窗口的源（协议+主机+端口号）。下面我们看一个例子： A.html 123456789101112131415161718192021 1 &lt;!DOCTYPE html&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 5 &lt;title&gt;A&lt;/title&gt; 6 &lt;body&gt; 7 &lt;p&gt;A&lt;/p&gt; 8 &lt;input type=&quot;button&quot; value=&quot;发送消息到frameB并得到frameB的回应&quot; onclick=&quot;sendMsg()&quot;&gt; 9 &lt;iframe id=&quot;frameB&quot; src=&quot;./B.html&quot; style=&quot;width: 90%;&quot;&gt;&lt;/iframe&gt;10 &lt;script type=&quot;text/javascript&quot;&gt;11 window.addEventListener(&quot;message&quot;, function (event) &#123;12 console.log(&quot;A.html接收到消息：&quot; + event.data);13 &#125;);14 15 function sendMsg () &#123;16 var frameB = document.getElementById(&quot;frameB&quot;);17 frameB.contentWindow.postMessage(&quot;Hello I am Li Lei&quot;, &quot;*&quot;);18 &#125;19 &lt;/script&gt;20 &lt;/body&gt;21 &lt;/html&gt; B.html 1234567891011121314151617 1 &lt;!DOCTYPE html&gt; 2 &lt;html&gt; 3 &lt;head&gt; 4 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; 5 &lt;title&gt;B&lt;/title&gt; 6 &lt;/head&gt; 7 &lt;body bgcolor=&quot;#ff0000&quot;&gt; 8 &lt;p&gt;B&lt;/p&gt; 9 &lt;script type=&quot;text/javascript&quot;&gt;10 window.addEventListener(&quot;message&quot;, function (event) &#123;11 console.log(&quot;B.html接收到消息：&quot; + event.data);12 //向发送消息的window回送消息13 event.source.postMessage(&quot;Hi, I am Han Meimei!&quot;, &quot;*&quot;);14 &#125;);15 &lt;/script&gt;16 &lt;/body&gt;17 &lt;/html&gt; 需要注意，window对象发送的消息只有自身可以接收到message消息。crossOrigin属性 服务端需要配置各种类型资源的跨域范围权限，如Apache服务器可以如下配置：复制代码 123456781 &lt;IfModule mod_setenvif.c&gt;2 &lt;IfModule mod_headers.c&gt;3 &lt;FilesMatch &quot;\\.(cur|gif|ico|jpe?g|png|svgz?|webp)$&quot;&gt;4 SetEnvIf Origin &quot;:&quot; IS_CORS5 Header set Access-Control-Allow-Origin &quot;*&quot; env=IS_CORS6 &lt;/FilesMatch&gt;7 &lt;/IfModule&gt;8 &lt;/IfModule&gt; Node.js如下配置： 1234567891011 1 app.all(&apos;*&apos;,function (req, res, next) &#123; 2 res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); 3 res.header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&apos;); 4 res.header(&apos;Access-Control-Allow-Methods&apos;, &apos;PUT, POST, GET, DELETE, OPTIONS&apos;); 5 if (req.method == &apos;OPTIONS&apos;) &#123; 6 res.send(200); /让options请求快速返回/ 7 &#125; else &#123; 8 next(); 9 &#125;10 &#125;); crossOrigin属性的值 该枚举属性指定在加载相关图片时是否必须使用CORS。 当不设置该属性时，资源将会不使用CORS加载（即不发送Origin:HTTP头），这将阻止其在元素中进行使用。若设置了非法的值，则视为使用anonymous。 &quot;anonymous&quot;：会发起一个跨域请求（即包含Origin: HTTP头）。但不会发送任何认证信息（即不发送cookie, X.509证书和HTTP基本认证信息）。如果服务器没有给出源站凭证（不设置Access-Control-Allow-Origin: HTTP头），这张图片就会被污染并限制使用。 &quot;use-credentials&quot;：会发起一个带有认证信息（发送cookie，X.509证书和HTTP基本认证信息）的跨域请求（即包含Origin:HTTP头）。如果服务器没有给出源站凭证（不设置Access-Control-Allow-Origin: HTTP头），这张图片就会被污染并限制使用。script标签 当我们引入一个不同源的js代码时，不设置crossOrigin属性，在执行上是没有问题的，报错在console面板也可以看到堆栈信息，但是在当前页面使用window.onerror来抓取错误时，只能得到一个Script error的信息，没有更多的信息了。 当我们为script标签添加crossorigin=”anonymous”属性后，如果服务端没有对跨域进行设置，会报如下错误： Access to Script at ‘http://127.0.0.1:3000/test.js&#39; from origin ‘http://192.168.2.34&#39; has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://192.168.2.34&#39; is therefore not allowed access. 服务端进行允许跨域设定后，window.onerror可以抓取到详细的信息了。img标签 我们在请求其它域下的图片时，可以显示出来，但是当调用toBlob()，toDataURL()和getImageData()等方法时会抛出安全错误，这是由于浏览器的安全策略导致的。 我们先看看下面的代码： 12345678910111213141516171819202122232425262728293031 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=&quot;en&quot;&gt; 3 &lt;head&gt; 4 &lt;meta charset=&quot;UTF-8&quot;&gt; 5 &lt;title&gt;Title&lt;/title&gt; 6 &lt;/head&gt; 7 &lt;body&gt; 8 &lt;canvas id=&apos;canvas&apos; width=&apos;500px&apos; height=&apos;500px&apos;&gt;&lt;/canvas&gt; 9 10 &lt;script&gt;11 var image = document.createElement(&quot;img&quot;);12 // image.crossOrigin = &quot;anonymous&quot;;13 image.onload = function() &#123;14 drawImg(image);15 &#125;;16 image.onerror = function() &#123;17 console.log(&quot;load image error!&quot;);18 &#125;;19 image.src = &quot;http://127.0.0.1:3000/images/img.png&quot;;20 21 function drawImg(img) &#123;22 var canvas = document.getElementById(&apos;canvas&apos;);23 var context = canvas.getContext(&quot;2d&quot;);24 context.drawImage(img, 0, 0, 100, 100);25 26 var base64 = canvas.toDataURL(&apos;image/png&apos;);27 console.log(base64);28 &#125;29 &lt;/script&gt;30 &lt;/body&gt;31 &lt;/html&gt; 图片不在当前域，可以绘制到canvas里显示，但是调用toDataURL时会出现跨域的报错，解决方法就是去掉注释，为img标签添加crossOrigin=”anonymous”的属性。 添加后，也需要服务端进行允许跨域设定才行哦，刷新后可以得到canvas中的图片编码信息，服务端不设定跨域会得到onerror的事件并且打印跨域异常信息。","categories":[],"tags":[]},{"title":"","date":"2019-08-11T11:10:52.424Z","path":"2019/08/11/css2/","text":"十一 、div垂直居中的方法1、flex布局给父级元素设为display:flex;justify-contnet:center //设置水片居中align-items:center //设置垂直居中可以设置css不定宽高水平垂直居中 123456789101112131415161718 &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt;&lt;/div&gt;.box &#123; background-color: #FF8C00; width: 300px; height: 300px; display: flex;//flex布局 justify-content: center;//使子项目水平居中 align-items: center;//使子项目垂直居中&#125;.content &#123; background-color: #F00; width: 100px; height: 100px;&#125; 2、position加已知宽度 父元素设置为：position: relative;子元素设置为：position: absolute;距上50%，据左50%，然后减去元素自身宽度的距离就可以实现 1234567891011121314151617181920212223 &lt;style&gt; .box &#123; background-color: #FF8C00; width: 300px; height: 300px; position: relative;--------- &#125; .content &#123; background-color: #F00; width: 100px; height: 100px; position: absolute;--------- left: 50%;---------- top: 50%;------------ margin:-50px 0 0 -50px;-----------width的一半 height的一半 &#125;&lt;/style&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt; 3、margin:auto兼容性：,IE7及之前版本不支持 123456789101112131415161718192021222324&lt;style&gt; .fa &#123; width: 300px; height: 300px; position: relative; border: 1px solid #465468;&#125;.SON &#123; position: absolute; margin: auto;------ top: 0;------- left: 0;----- right: 0;---- bottom: 0;----- width:50px; height:60px; background:red;&#125;&lt;/style&gt; &lt;div class=&quot;fa&quot;&gt; &lt;div class=&quot;SON&quot;&gt;&lt;/div&gt; &lt;/div&gt; 4、 Transforms兼容性：IE8不支持；当前div的父级添加相对定位（position: relative;） 12345678910div&#123; width: 200px; height: 200px; background: green; position:absolute; left:50%; /* 定位父级的50% */ top:50%; transform: translate(-50%,-50%); /*自己的50% */&#125; 十二、行内元素的水平垂直居中水平居中 1、利用 text-align: center 可以实现在块级元素内部的内联元素水平居中。 此方法对内联元素(inline), 内联块(inline-block), 内联表(inline-table), inline-flex元素水平居中都有效。 1234&lt;div class=&quot;text&quot;&gt;sgdhygjgu&lt;/div&gt;.text&#123; text-align:center;&#125; 2、利用inline-block 如果一行中有两个或两个以上的块级元素，通过设置块级元素的显示类型为inline-block和父容器的text-align属性从而使多块级元素水平居中。 垂直居中 通过设置内联元素的高度(height)和行高(line-height)相等，从而使元素垂直居中。 利用表布局（table）,利用表布局的vertical-align: middle可以实现子元素的垂直居中。table-cell实现水平垂直居中: table-cell middle center组合使用12345678910111213 &lt;div class=&quot;table-cell&quot;&gt; &lt;p&gt;我爱你&lt;/p&gt;&lt;/div&gt;.table-cell &#123; display: table-cell; vertical-align: middle; text-align: center; width: 240px; height: 180px; border:1px solid #666;&#125; 利用“精灵元素”(ghost element)技术实现垂直居中，即在父容器内放一个100%高度的伪元素，让文本和伪元素垂直对齐，从而达到垂直居中的目的。 十三、三列布局的七种方法1、flex中间设置flex:1 简单、优雅 未来趋势 移动端尽情使用 兼容性差一点，不支持 IE8、IE9 顺序Left center right 1234567891011121314151617181920212223&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧栏&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;中间&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧栏&lt;/div&gt;&lt;/div&gt; .container &#123; display: flex;&#125;.left &#123; flex: 0 0 100px; background-color: #f00;&#125;.main &#123; flex: 1;------------- background-color: #0f0;&#125;.right &#123; flex: 0 0 200px; background-color: #00f;&#125; 2、浮动左栏左浮动，右栏右浮动，中间主体放在左栏右栏后面（中间栏会占据整行），中间的宽度不固定，但是要加上margin左右的宽度顺序left right center 123456789101112131415161718192021222324252627&lt;style&gt;.left&#123; width:400px; height:500px; background:red; float:left;&#125;.center&#123; height:500px; background:yellow; margin-left:470px; margin-right:470px;&#125;.right&#123; width:400px; height:500px; background:red; float:right;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;div class=&quot;center&quot;&gt;&lt;/div&gt; 3、定位position两边用绝对定位，中间用margin，左右宽度固定，中间宽度不固定，中间主体放在左栏右栏后面（中间栏会占据整行）顺序是left right center 1234567891011121314151617181920212223242526272829&lt;style&gt;.left&#123; width:400px; height:500px; background:red; position:absolute; left:0;&#125;.center&#123; height:500px; background:yellow; margin-left:470px; margin-right:470px;&#125;.right&#123; width:400px; height:500px; background:red; position:absolute; right:0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;left&quot;&gt;&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;div class=&quot;center&quot;&gt;&lt;/div&gt; 4、table简单 缺乏点灵活性 1234567891011121314151617181920212223&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;左侧栏&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;中间&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧栏&lt;/div&gt;&lt;/div&gt;.container &#123; display: table;&#125;.left &#123; display: table-cell; width: 100px; background-color: #f00;&#125;.right &#123; display: table-cell; width: 200px; background-color: #00f;&#125;.main &#123; display: table-cell; background-color: #0f0;&#125; 5、gridclass12345678910111213141516171819 &lt;div class=&quot;left&quot;&gt;左侧栏&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;中间&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧栏&lt;/div&gt;&lt;/div&gt; .container &#123; display: grid; grid-template-columns: 100px auto 200px;&#125;.left &#123; background-color: #f00;&#125;.right &#123; background-color: #00f;&#125;.main &#123; background-color: #0f0;&#125; 6、圣杯 中间内容放在最上面，保证先渲染 精髓还是负边距 123456789101112131415161718192021222324252627282930.container &#123; padding: 0 300px 0 200px;&#125;.content &#123; float: left; width: 100%; background: #f00;&#125;.left &#123; position: relative; left: -200px; float: left; width: 200px; margin-left: -100%; background: #0f0;&#125;.right &#123; position: relative; right: -300px; float: left; width: 300px; margin-left: -300px; background: #00f;&#125;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;中间内容区域&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;左侧边栏区域&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧边栏区域&lt;/div&gt;&lt;/div&gt; 7、双飞翼区别：圣杯布局是中间栏在添加相对定位，并配合 left 和 right 属性，效果上表现为三栏是单独分开的 双飞翼布局是在中间栏的 div 中嵌套一个 div，内容写在嵌套的 div 里，然后对嵌套的 div 设置 margin-left 和 margin-right，效果上表现为左右两栏在中间栏的上面，中间栏还是 100% 宽度，只不过中间栏的内容通过 margin 的值显示在中间 通过两者实现的截图红色区域可以很明显看到两者区别 12345678910111213141516171819202122232425262728.container &#123; float: left; width: 100%; background: #f00;&#125;.content &#123; margin-left: 200px; margin-right: 300px;&#125;.left &#123; float: left; width: 200px; margin-left: -100%; background: #0f0;&#125;.right &#123; float: left; width: 300px; margin-left: -300px; background: #00f;&#125; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;content&quot;&gt;中间内容区域&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;left&quot;&gt;左侧边栏区域&lt;/div&gt;&lt;div class=&quot;right&quot;&gt;右侧边栏区域&lt;/div&gt; 十四、网页渲染之—–回流(重排Reflow)与重绘(Repaint)在讨论回流与重绘之前，我们要知道： 浏览器使用流式布局模型 (Flow Based Layout)。浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用table布局的原因之一。 ####一句话：回流必将引起重绘，重绘不一定会引起回流。 （一）回流对回流这个词，我的理解是回炉重造，即对于整个网页重新渲染一遍。那我们可以思考一下，从性能角度来讲，如果我们来写浏览器的代码，一定是再必须要重新渲染网页的时候再重新渲染，那就推出一个问题，什么时候浏览器必须要重新渲染网页？ 重新渲染全部或部分文档的动作我们就叫做回流所以会导致回流的操作(包括但不限于)： 页面首次渲染 浏览器窗口大小发生改变 元素尺寸或位置发生改变 元素内容变化（文字数量或图片大小等等） 元素字体大小变化 添加或者删除可见的DOM元素 激活CSS伪类（例如：:hover）（二）重绘当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。性能影响回流比重绘的代价要更高。有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。当你访问以下属性或方法时，浏览器会立刻清空队列： clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft width、height getComputedStyle() getBoundingClientRect() 因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。 如何避免 CSS 1.避免使用table布局。2.尽可能在DOM树的最末端改变class。3.避免设置多层内联样式。4.将动画效果应用到position属性为absolute或fixed的元素上。5.避免使用CSS表达式（例如：calc()）。 JavaScript 1.避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。 2.避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。 3.也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。 4.避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。 5.对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。 十五、BOMBom：浏览器对象模型（Browser Object Model，简称 BOM）提供了独立于内容而与浏览器窗口进行交互的对象。描述了与浏览器进行交互的方法和接口，可以对浏览器窗口进行访问和操作 （1）window对象：当前浏览器窗体 属性： status：状态栏(目前浏览器已弃用了） opener：即谁打开我的，若在A用open打开B则B的opener就是A closed：判断子窗体是否关闭——- 方法：alert() 弹出框 confirm() 带确认,取消弹出框 setInterval() 每隔多少秒调用一次 clearInterval() 清除setInterval setTimeout() 隔多少秒调用一次 cleartimeout() 清除setTimeout open() 打开一个新的窗口 eg : window.open(“other.html”,” _blank”,”width=200,height=300,top=300”); console:最常用的就是console.log()浏览器控制台打印 （2）子对象：doument loation history screen …… 1、 doument （讲dom已经介绍过它的属性方法 ，有感兴趣的可以翻看dom操作） 2、 loation 跳转位置 12345&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3; url =http://www.hteis.cn&quot;;&gt; //不加url指3秒刷新一次，加url指3秒跳转window.location.href=&quot;popl.html&quot;;location = pop.htmllocation.replace(&quot;pop.html&quot;) //浏览器不可以后退 3、 history 历史history.back() == history.go(-1) //返回到前一页history.go(-2) //括号里的参数负几就是返回前几步 123 eg: &lt;a href=&quot;javascript:history.back()&quot;&gt;返回上一页&lt;/a&gt; &lt;a href=&quot;javascript:history.go(-2)&quot;&gt;第一页&lt;/a&gt; 4、 screen //屏幕screen.availHeight //屏幕实际高度screen.availWidth //屏幕实际宽度screen.height //屏幕高度screen.width //屏幕宽度 console.log(“屏幕实际高度”+screen.availHeight);console.log(“屏幕实际宽度”+screen.availWidth);console.log(“屏幕高度”+screen.height);console.log(“屏幕宽度”+screen.width);","categories":[],"tags":[]},{"title":"","date":"2019-08-11T03:58:38.425Z","path":"2019/08/11/css1/","text":"盒模型&amp;边界崩塌&amp;浮动&amp;行与块一、盒模型1.什么是盒模型： 盒模型，顾名思义，就是一个盒子。生活中的盒子，有长宽高，盒子本身也有厚度，可以用来装东西。页面上的盒模型我们可以理解为，从盒子顶部俯视所得的一个平面图，盒子里装的东西，相当于盒模型的内容（content）；东西与盒子之间的空隙，理解为盒模型的内边距（padding）；盒子本身的厚度，就是盒模型的边框（border）；盒子外与其他盒子之间的间隔，就是盒子的外边距（margin）。 元素的外边距（margin）、边框（border）、内边距（padding）、内容（content）就构成了CSS盒模型。 2.盒模型的区别： CSS盒模型分为IE盒模型（图2）和W3C盒模型（图3）。其实，IE盒模型是怪异模式（Quirks Mode）下的盒模型，而W3C盒模型是标准模式（Standards Mode）下的盒模型。 IE6及其更高的版本，还有现在所有标准的浏览器都遵循的是W3C盒模型，IE6以下版本的浏览器遵循的是IE盒模型。 [图二] [图三] 从上图直观的可以看出，IE盒模型的宽度或者高度计算方式为：width/height = content + padding + border，W3C盒模型的宽度或者高度计算方式为：width/height = content。 举一个简单的例子：一个div的宽度和高度为100px，内边距为10px，边框为5px，外边距为30px。图4为不同模型下显示的结果，W3C盒模型下显示的div所占的总宽度和总高度（包括外边距、边框、内边距、内容）为100 + 10 + 5 + 30 = 145px，IE盒模型下显示的div所占的总宽度和总高度（包括外边距、边框、内边距、内容）为100 + 30 = 130px。很明显的区别，如果元素的宽度（width）一定的情况下，W3C盒模型的宽度（width）不包括内边距和边框，IE盒模包括。 3.如何切换两种盒模型： CSS3新增了一个属性box-sizing: content-box | border-box | inherit，默认值为content-box。 虽说现在的浏览器都兼容该属性，还是得以防万一，在属性前最好暂时加-webkit-和-moz-前缀 如果值为content-box，那元素遵循的是W3C盒模型； 如果值为border-box，那元素遵循的是IE盒模型； 如果值为inherit，该属性的值应该从父元素继承。 二、margin引发的边界崩塌 1.当两个对象为上下关系时，而且都具备margin属性时，上面的margin-bottom与下面的margin-top会发生塌陷 当margin-bottom和margin都为正数时，结果为两者之间的最大值 当margin-bottom和margin-top都为负时，结果为两者绝对最较大的那个值。 当margin-bottom和margin-top为一正一负时，结果为两者之和。 2.当两个对象为上下包含关系 父元素无填充内容，且没有设置border时，子元素的margin-top不会起作用 父元素设置border属性，子元素的margin-top起作用 父元素有填充内容，子元素的margin-top会起作用，当margin-top小于填充内容时，距离为填充内容的高度 ## 三、BFC ### 1. BFC是什么？ (一)、Block fomatting context = block-level box + Formatting Context (1) Box: Box即盒子模型； block-level box即块级元素display属性为block, list-item, table的元素，会生成block-level box；并且参与 block fomatting context； inline-level box即行内元素display 属性为 inline, inline-block, inline-table的元素，会生成inline-level box。并且参与 inline formatting context； （二）、BFC 定义 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 2.BFC的生成上文提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素决定，CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption display：table也认为可以生成BFC，其实这里的主要原因在于Table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC position的值为absolute或fixed 3. BFC的约束规则 内部的Box会在垂直方向上一个接一个的放置 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。） 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界） BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 看到以上的几条约束，想想我们学习css时的几条规则: Block元素会扩展到与父元素同宽，所以block元素会垂直排列 垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会(此规则并不完全正确) 浮动元素会尽量接近往左上方（或右上方） 为父元素设置overflow：hidden或浮动父元素，则会包含浮动元素 四、浮动(一)浮动产生原因：一般是一个盒子里使用了CSS float浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了。 (二)浮动产生的副作用#####1、背景不能显示由于浮动产生，如果对父级设置了（CSS background背景）CSS背景颜色或CSS背景图片，而父级不能被撑开，所以导致CSS背景不能显示。 #####2、边框不能撑开如上图中，如果父级设置了CSS边框属性（css border），由于子级里使用了float属性，产生浮动，父级不能被撑开，导致边框不能随内容而被撑开。 #####3、margin padding设置值不能正确显示由于浮动导致父级子级之间设置了css padding、css margin属性的值不能正确表达。特别是上下边的padding和margin不能正确显示。 五、清除浮动方法####1、对父级设置适合CSS高度原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单，代码少，容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 2、clear:both清除浮动为了统一样式，我们新建一个样式选择器CSS命名为“.clear”，并且对应选择器样式为“clear:both”，然后我们在父级“”结束前加此div引入“class=”clear””样式。这样即可清除浮动。这里强调一点，即在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度。原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：通俗易懂，容易掌握 缺点：会添加很多无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 1234567891011121314css:.divcss5&#123; width:400px;border:1px solid #F00;background:#FF0&#125; .divcss5-left,.divcss5-right&#123;width:180px;height:100px; border:1px solid #00F;background:#FFF&#125; .divcss5-left&#123; float:left&#125; .divcss5-right&#123; float:right&#125; .clear&#123; clear:both&#125;html:&lt;div class=&quot;divcss5&quot;&gt; &lt;div class=&quot;divcss5-left&quot;&gt;left浮动&lt;/div&gt; &lt;div class=&quot;divcss5-right&quot;&gt;right浮动&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;&lt;/div&gt; 3、父级div定义 overflow:hidden对父级CSS选择器加overflow:hidden样式，可以清除父级内使用float产生浮动。优点是可以很少CSS代码即可解决浮动产生。原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单，代码少，浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用 4、父级div定义伪类:after和zoom(用于非IE浏览器)原理：IE8以上和非IE浏览器才支持:after，原理和方法1有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）。缺点：代码多，要两句代码结合使用，才能让主流浏览器都支持建议：推荐使用，建议定义公共类，以减少CSS代码 display:block 使生成的元素以块级元素显示,占满剩余空间; height:0 避免生成内容破坏原有布局的高度。 visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互。 通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX”,有些版本可能content 里面内容为空,不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙； zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来清除浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：05、父级div定义overflow:auto原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度优点：简单，代码少，浏览器支持好缺点：内部宽高超过父级div时，会出现滚动条。建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 六 、行内元素和块元素 块元素：不管内容多少，块元素都会在浏览器中独占一行。可设置宽高，如果不设置宽高那么它的宽度是100%（占满父级元素一整行） 缺点：1.相邻元素垂直。相邻外边距会重叠。margin-bottom和margin-top重叠（重叠之后的值是两个值中的最大值） 第一种解决方案：原理bfc相关 2.父子的相邻，父元素的margin-top和子元素的margin-top发生重叠 （重叠之后的值是两个值中的最大值） 关于父子相邻的解决方案： 第一种解决方案.取消相邻，给父元素设置border或者padding-top 让相邻之间有间隔。 第二种解决方案，父元素加overflow:hidden属性 -- 原理bfc相关 块元素包括：div， h1-h6 ， p ，ul，li，ol， dl，dt, hr，form,table ，tr，td 行内元素：内容决定所占空间的多少，内容多少就占多少空间。不能设置宽高（默认宽高是0）。margin垂直方向无效（margin-top,margin-bottom）,如果设置垂直方向用line-height属性。 多个行内元素排列在一起，他们之间会出席空格。 行内元素包括：font , span, b , i , u, sub, sup, a , 标红为常见的块元素和行内元素。 行内块：共享一行，可设置宽高,多个行内元素排列在一起，他们之间会出席空格。可设置margin,padding属性。集合了块和行内的所有优点。 行内块元素包括：img,input 注意：设置两个并排的div.一个width:20%,一个width:80%.用display:inline-block 让两个div并排，会使右侧的div向下排列 七、position定位position属性共有四种不同的定位方法，分别是static、fixed、relative、absolute。 position:static static定位是HTML元素的默认值，即没有定位，元素出现在正常的流中。因此这种定位就不会受到top、bottom、left、right的影响 &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;/div&gt; .wrap{height: 200px;width: 200px;background-color: #ddd;} .content{height: 80px;width: 80px;background-color: rgb(228,183,41);position: static;top: 20px;left: 20px;} position:fixedfixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的他也不会滚动，而且fixed定位使元素的位置与文档流无关，因此不占据空间，所以会和其他元素发生重叠。 position:relative 相对定位元素的定位是相对他自己的正常位置定位。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。 position:absolute 生成绝对定位的元素，其相对于 static 定位以外的第一个父元素进行定位,会脱离normal flow。如果第一个父元素没有position，就找下一个父元素相对它定位，如果都没有就相对body定位 注意：是除了static外 八、伪类和伪元素（一）、伪类和伪元素是什么 伪类：为了通过选择器，格式化DOM树以外的信息(匹配指定状态的元素):visited，:active 。 以及不能被常规CSS选择器获取到的信息(满足一定逻辑条件的DOM树中的元素)，比如:first-child，:first-of-type，：target。 伪元素：可以创建一些文档语言无法创建的虚拟元素。比如：文档语言没有一种机制可以描述元素内容的第一个字母或第一行，但伪元素可以做到(::first-letter、::first-line)。同时，伪元素还可以创建源文档不存在的内容，比如使用 ::before 或 ::after。 伪类的功能有两种：1.格式化DOM树以外的信息。比如：a 标签的:link。或者:hover。这些信息不存在于DOM树中。2.不能被常规CSS选择器获取到的信息。比如：要获取第一个子元素，我们无法用常规的CSS选择器获取，但可以通过 :first-child 来获取到。 伪类种类属性 :active —— 向被激活的元素添加样式。:focus——向拥有键盘输入焦点的元素添加样式。:hover——当鼠标悬浮在元素上方时，向元素添加样式。:link——向未被访问的链接添加样式。:visited——向已被访问的链接添加样式。:first-child——向元素的第一个子元素添加样式。:last-child——匹配最后一个子元素。:first-of-type——匹配属于其父元素的第一个特定类型的子元素。:last-of-type匹配属于其父元素的最后一个特定类型的子元素。:lang——向带有指定 lang 属性的元素添加样式。:enable 选择每个已启动的元素 3:disable 选择每个已禁止的元素 3:checked 选择每个被选中的元素 3:target 选择当前的锚点元素 3:only-of-type 选择满足是其父元素的唯一一个某类型子元素的元素 3:nth-of-type(n) 选择满足是其父元素的第n个某类型子元素的元素3:nth-last-of-type(n) 选择满足是其父元素的倒数第n个某类型的元素 3:only-child 选择满足是其父元素的唯一一个子元素的元素 3:last-child 选择满足是其父元素的最后一个元素的元素 3:nth-child(n) 选择满足是其父元素的第n个子元素的元素3:nth-last-child(n) 选择满足是其父元素的倒数第n个子元素的元素 3:empty 选择满足没有子元素的元素 3:in-range 选择满足值在指定范围内的元素 3:out-of-range 选择值不在指定范围内的元素 3:invalid 选择满足值为无效值的元素 3:valid 选择满足值为有效值的元素 3:not(selector) 选择不满足selector的元素 3:optional 选择为可选项的表单元素，即没有“required”属性 3:read-only 选择有&quot;readonly&quot;的表单元素3:read-write 选择没有&quot;readonly&quot;的表单元素 3:root 选择根元素 伪元素属性 ::first-letter——向文本的第一个字母添加特殊样式。::first-line——向文本的首行添加特殊样式。::before——在元素之前添加内容。::after——在元素之后添加内容。::selection 选择指定元素中被用户选中的内容 (二) 、区别伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 八、文档流和脱离文档流 文档流是指在网页中将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流.(自己的理解是从头到尾按照文档的顺序，该在什么位置就在什么位置，自上而下，自左到右的顺序),这是普通流的说法。 而很多时候会出现影响普通流而存在，最典型的就是浮动、定位(相对定位和绝对定位) 1.浮动 浮动常用在块级元素上，普通流里的块级元素会独占一行，而应用了float的元素就脱离了文档流，可以多个一排，其作用与display:inline-block相似。由于脱离文档流的元素是不占据空间的，所以添加了CSS浮动的元素会对其周围的其他元素产生或多或少的影响。 2.定位 相对定位：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。即相对元素在文档流中的位置进行偏移，保留占位。 绝对定位，绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。而绝对定位完全脱离文档流，相对于position属性非static值的最近父元素进行偏移。 固定定位，元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身，用fixed,他是完全脱离文档流，相对于视区进行偏移。 文档流其实就是文档中可显示对象在排列时所占用的位置。 九、什么叫优雅降级和渐进增强？1.优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 2.渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 常见的浏览器：Chrome(WebKit)、Firefox(Gecko)、、Opera(resto)、IE(Trident内核) 前端兼容性问题一：padding在Firefox设置了 padding 一后，div会增加 height 和 width，但IE不会 。 解决方式：尝试使用 height:100%或者控制好高度;宽度减少使用 padding但根据实际经验，一般Firefox和IE的 padding 不会有太大区别，div 的实际宽 = width + padding ，所以div写全 width 和 padding，width 用实际想要的宽减去 padding 定义。 前端兼容性问题二：高度两上下排列或嵌套的div，上面的div设置height，如果div里的实际内容大于所设高度，在Firefox中会出现两个div重叠的现象；在IE中，下面的div会自动给上面的div让出空间 解决方式：高度要控制恰当，比较好的方法是 height:100%;但当这个div里面一级的元素都float了的时候，则需要在div块的最后，闭和前加一个沉底的空div，对应CSS是： .float_bottom {clear:both;height:0px;font-size:0px;padding:0;margin:0;border:0;line-height:0px;overflow:hidden;} 前端兼容性问题三：IE浮动margin产生的双倍距离 前端兼容性问题四：clear:both;不想受到float浮动的，就在div中写入clear:both; 前端兼容性问题五：居中问题div里的内容，IE默认为居中，而Firefox默认为左对齐，可以尝试增加代码margin: 0 auto; 前端兼容性问题六：列表类 ul标签在FF中默认是有 padding值的，而在IE中只有margin有值先定义 ul {margin:0;padding:0;} ul和ol列表缩进问题消除ul、ol等列表的缩进时，样式应写成:{list-style:none;margin:0px;padding:0px;} 前端兼容性问题七：显示类（display:block,inline）1.display:block,inline两个元素 display:block; //可以为内嵌元素模拟为块元素 display:inline; //实现同一行排列的的效果 display:table; //for FF,模拟table的效果 display:block 块元素，元素的特点是： 总是在新行上开始；高度，行高以及顶和底边距都可控制；宽度缺省是它的容器的100%，除非设定一个宽度 123&lt;div&gt;，&lt;p&gt;，&lt;h1&gt;，&lt;form&gt;，&lt;ul&gt; 和 &lt;li&gt; 是块元素的例子display:inline 就是将元素显示为行内元素，元素的特点是：和其他元素都在一行上；高，行高及顶和底边距不可改变；宽度就是它的文字或图片的宽度，不可改变。&lt;span&gt;，&lt;a&gt;，&lt;label&gt;，&lt;input&gt;，&lt;img&gt;，&lt;strong&gt; 和 &lt;em&gt; 是 inline 元素的例子 2.鼠标手指状显示 全部用标准的写法 cursor: pointer; 前端兼容性问题八:背景、图片类 background显示问题 全部注意补齐 width，height 属性 2.背景透明问题 IE: filter: progid: DXImageTransform.Microsoft.Alpha(style=0,opacity=60); IE: filter: alpha(opacity=10); Firefox: opacity:0.6; Firefox: -moz-opacity:0.10; 最好两个都写，并将opacity属性放在下面 前端兼容性问题九:min-height最小高度的实现（兼容IE6、IE7、Firefox）作用是：当容器的内容较少时，能保持一个最小的高度，以免破坏了布局或UI设计效果。而当容器内的内容增加的时候，容器能够自动的伸展以适应内容的变化。 前端兼容性问题十：为什么web标准中无法设置IE浏览器滚动条颜色了？原来样式设置： 解决办法是将body换成html。 十、flexflex 是 flex-grow、flex-shrink、flex-basis的缩写,flex 的默认值是 0 1 auto flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 当 flex 取值为 none，则计算值为 0 0 auto. 当 flex 取值为 auto，则计算值为 1 1 auto. 当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%， 123456.item &#123;flex: 1;&#125;.item &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125; 当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0% 123456789.item &#123;flex: 2 3;&#125;.item &#123; flex-grow: 2; flex-shrink: 3; flex-basis: 0%;&#125;. 当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1 123456.item &#123;flex: 2333 3222px;&#125;.item &#123; flex-grow: 2333; flex-shrink: 1; flex-basis: 3222px;&#125; flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1， 123456789101112.item-1 &#123;flex: 0%;&#125;.item-1 &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 0%;&#125;.item-2 &#123;flex: 24px;&#125;.item-1 &#123; flex-grow: 1; flex-shrink: 1; flex-basis: 24px;&#125; flex-flow举例123456789101112131415161718192021222324252627282930&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;item-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item-3&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style type=&quot;text/css&quot;&gt; .parent &#123; display: flex; width: 600px; &#125; .parent &gt; div &#123; height: 100px; &#125; .item-1 &#123; width: 140px; flex: 2 1 0%; background: blue; &#125; .item-2 &#123; width: 100px; flex: 2 1 auto; background: darkblue; &#125; .item-3 &#123; flex: 1 1 200px; background: lightblue; &#125;&lt;/style&gt; 主轴上父容器总尺寸为 600px 子元素的总基准值是：0% + auto + 200px = 300px，其中 0% 即 0 宽度 auto 对应取主尺寸即 100px故剩余空间为 600px - 300px = 300px 伸缩放大系数之和为： 2 + 2 + 1 = 5 剩余空间分配如下： item-1 和 item-2 各分配 2/5，各得 120px item-3 分配 1/5，得 60px各项目最终宽度为： item-1 = 0% + 120px = 120px item-2 = auto + 120px = 220px item-3 = 200px + 60px = 260px 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间 flex-shrink举例现在三个子div的宽度是600px, 外层div的宽度设置成500px, 那么不够显示的600-500 px应该怎么让子div们收缩掉这100px。 1234567891011121314151617181920212223242526272829html部分： &lt;div class=&quot;outer&quot;&gt; &lt;div class=&apos;div1&apos;&gt;1&lt;/div&gt; &lt;div class=&apos;div2&apos;&gt;2&lt;/div&gt; &lt;div class=&quot;div3&quot;&gt;3&lt;/div&gt;&lt;/div&gt;css部分：.outer &#123; width: 500px; display: flex;&#125;.outer div &#123; height: 80px;&#125; .div1 &#123; flex: 1 1 100px; background: red;&#125;.div2 &#123; flex: 1 2 200px; background: yellow;&#125;.div3 &#123; flex: 1 3 300px; background: green;&#125; 先计算总权重TW = 100px * 1(flex-shrink) + 200px *2(flex-shrink) + 300px *3(flex-shrink) = 1400px 也就是每个div的宽度乘以flex-shrink系数的总和。 每个div收缩的空间为：div的宽度 * flex-shrink系数/ 总权重TW * 需要收缩的总宽度（在我们的例子中是600px - 500px = 100px） 所以各div最后的宽度计算公式如下： div1最后的宽度 = 100px - 100*1/1400 * 100px = 92.86px div2最后的宽度 = 200px - 200*2/1400 * 100px = 171.42px div3最后的宽度 = 300px - 300*3/1400 * 100px = 235.72px 参考链接：https://www.cnblogs.com/ranyonsue/p/9204986.html","categories":[],"tags":[]},{"title":"Hello World","date":"2019-08-11T03:43:41.845Z","path":"2019/08/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]